package lab2;

import java.math.BigInteger;
import java.util.Random;

public class RSA {
	
	static BigInteger n1;
	static BigInteger n2;
	static BigInteger e;
	//check 2 number is relatively prime
	private static boolean getPrime(BigInteger n, BigInteger m) {
		
		if(n.isProbablePrime(100) && m.isProbablePrime(100) && n != m)
		{
			return true;
		}
		else return false;
	}
	
	
	
	public static BigInteger[] keys(BigInteger n1, BigInteger n2)
	{
		BigInteger[] r = new BigInteger[3];
		BigInteger pq = n1.multiply(n2);
		BigInteger ola = n1.subtract(BigInteger.ONE).multiply(n2.subtract(BigInteger.ONE));
		e =  BigInteger.probablePrime(1024, new Random());
		while(ola.gcd(e) != BigInteger.ONE && e.compareTo(ola) == 1 && ola == e )
		{
			e =  BigInteger.probablePrime(1024, new Random());
			//System.out.println(e);		
		}
		BigInteger d = e.modInverse(ola);
		
		System.out.println("n is: " + pq);
		System.out.println("ola of n is: " + ola);
		System.out.println("e is: " + e);
		System.out.println("d is: " + d);
		
		//public key is (pq, e)   private key is (pq, d)
		r[0] = pq;
		r[1] = e;
		r[2] = d;
		return r;
	}

	private static BigInteger encript(String data, BigInteger pubK1, BigInteger pubK2)
	{
		
	

		byte[] tobyte = data.getBytes();
		
		BigInteger dataInte = new BigInteger(toBinary(data));
		System.out.println(tobyte);
		BigInteger senddata = dataInte.modPow(pubK2, pubK1);
		return senddata;
		
	}
	private static String decript(BigInteger getdata, BigInteger priK1, BigInteger priK2)
	{
		BigInteger getInteger = getdata.modPow(priK2, priK1);
		
		byte[] getbyte = getInteger.toByteArray();
		
		return new String(getbyte);
	}
	
	
	public static void main(String args[]) {
		
		 n1 = BigInteger.probablePrime(1024, new Random());
		 n2 = BigInteger.probablePrime(1024, new Random());
		
		 while(getPrime(n1,n2) == false)
		 {
			 n1 = BigInteger.probablePrime(1024, new Random());
			 n2 = BigInteger.probablePrime(1024, new Random());
		 }
		
		 System.out.println("number 1: " + n1);
	 System.out.println("number 2: " + n2);
		System.out.println("They are relatively prime");
		BigInteger[] k = keys(n1,n2);
		
		String message = "hello joe";
		BigInteger encri = encript(message, k[0], k[1]);
		
		System.out.println("send data: "+encri);
		
		//String getdata = decript(encri, k[0],k[2]);
		//System.out.println("receive data: "+getdata);
		String d = toBinary(message);
		System.out.println(d);
		System.out.println(toString(d));
		
	}
	
	
	public static String toBinary(String str){
        //把字符串转成字符数组
        char[] strChar=str.toCharArray();
        String result="";
        for(int i=0;i<strChar.length;i++){
           
            result +=Integer.toBinaryString(strChar[i])+" ";
        }
        return result;
    }
	
	public static String toString(String binary) {
        String[] tempStr=binary.split(" ");
           char[] tempChar=new char[tempStr.length];
           for(int i=0;i<tempStr.length;i++) {
              tempChar[i]=BinstrToChar(tempStr[i]);
           }
           return String.valueOf(tempChar);
   }

	 public static int[] BinstrToIntArray(String binStr) {       
	        char[] temp=binStr.toCharArray();
	        int[] result=new int[temp.length];   
	        for(int i=0;i<temp.length;i++) {
	            result[i]=temp[i]-48;
	        }
	        return result;
	    }
	

	private static char BinstrToChar(String string) {
		 int[] temp=BinstrToIntArray(string);
	        int sum=0;
	        for(int i=0; i<temp.length;i++){
	            sum +=temp[temp.length-1-i]<<i;
	        }   
	        return (char)sum;
	
	}


}
